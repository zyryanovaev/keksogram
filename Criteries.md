# Критерии

## Базовые критерии

### Задача

* Б1. Код соответствует техническому заданию проекта
* Б2. При выполнении кода не возникает необработанных ошибок

### Именование

* Б3. Название переменных, параметров, свойств и методов начинается со строчной буквы и записываются в нотации [CamelCase](https://ru.wikipedia.org/wiki/CamelCase)
* Б4. Для названия значений используются английские существительные. Сокращения в словах запрещены, кроме:
  * `xhr`, для объектов `XMLHttpRequest`
  * `evt` для объектов `Event` и его производных (`MouseEvent`, `KeyboardEvent` и подобные)
  * `ctx` для контекста канваса
  * `i`, `j`, `k`, `l`, `t` для счётчика в цикле, `j` для счётчика во вложенном цикле и так далее по алфавиту
  * если циклов два и более, то можно не переиспользовать переменную `i`
  * `cb` для единственного коллбэка в параметрах функции
* Б5. Массивы названы существительными во множественном числе
* Б6. Название функции или метода содержит глагол. Кроме случаев:
  * Функции конструкторы (см. критерий Б4)
  * Функции обработчики/коллбэки (см. критерий Д4)
* Б7. Названия констант (постоянных значений) написаны прописными (заглавными) буквами
* Б8. Название конструкторов и перечислений начинается с заглавной буквы. В названии используются английские существительные.

### Форматирование и внешний вид

* Б9. Используются обязательные блоки кода (скобки, запятые, точки с запятой и т.п.)
* Б10. Список констант идёт перед основным кодом
* Б11. Код соответствует гайдлайнам

### Мусор

* Б12. В итоговом коде проекта находятся только те файлы, которые были на момент создания репозитория, которые были получены в патчах и файлы, созданные по заданию
* Б13. В коде проекта нет файлов, модулей и частей кода, которые не используются, включая, закомментированные участки кода
* Б14. В коде нет заранее недостижимых участков кода

### Корректность

* Б15. Константы нигде в коде не переопределяются
* Б16. Включён строгий режим
* Б17. Используются строгие сравнения вместо нестрогих
* Б18. В коде не используются [зарезервированные слова](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#Keywords) в качестве имён переменных и свойств

### Модульность

* Б19. Все скрипты подключаются через файл index.html
* Б20. Все файлы JS представляют собой отдельные модули в IIFE
* Б21. Все значения, используемые только внутри модулей ограничены по видимости

### Универсальность

* Б22. Код является кроссбраузерным и не вызывает ошибок в разных браузерах и разных операционных системах

### Магия

* Б23. Нельзя пользоваться глобальной переменной `event`, нужно заменять на `evt` и производные `KeyUpEvt`

### Оптимальность

* Б24. Своевременный выход из цикла: цикл не работает дольше чем нужно
* Б25. Количество вызовов циклов минимизировано
* Б26. Множественные DOM-операции производятся на элементах, которые не добавлены в DOM

### Безопасность

* Б27. Обработчики события добавляются и удаляются своевременно
* Б28. Для вставки пользовательских строк (имён, фамилий и т.д.) использован textContent

## Дополнительные критерии

### Задача

* Д1. Техническое задание реализовано в полном объёме

### Именование

* Д2. Переменные носят абстрактные названия и не содержат имён собственных
* Д3. Название методов и свойств объектов не содержит название объектов. Например, `popup.open` вместо `popup.openPopup`
* Д4. Из названия обработчика события и функции-коллбэка следует, что это обработчик: `on + (на каком элементе) + что случилось` или `(на каком элементе) + что случилось + Handler`. Например, `onPictureClick` или `pictureClickHandler`

### Единообразие

* Д5. Все функции объявлены единообразно
* Д6. Используется единый стиль именования переменных
  * не следует мешать обработчики содержащие `Handler` и `on`
  * если переменные, которые хранят DOM-элемент и содержат слово `Element`, то это правило работает везде.
* Д7. При использовании встроенного API, который поддерживает несколько вариантов использования, используется один способ

### Корректность

* Д8. API встроенных функций и объектов используется правильно
* Д9. Отсутствуют потенциально некорректные операции

### Модульность

* Д10. В случае, если одинаковый код повторяется в нескольких модулях, повторяющаяся часть вынесена в отдельный модуль
* Д11. При экспорте из одного модуля нескольких значений используется пространство имён
* Д12. Во всех модулях для ограничения области видимости используются IIFE и только они

### Избыточность

* Д13. В проекте не должно быть избыточных проверок
* Д14. Отсутствует дублирование кода: повторяющиеся части кода переписаны как функции. Выдерживается принцип [DRY](https://ru.wikipedia.org/wiki/Don’t_repeat_yourself)
* Д15. Если при использовании условного оператора в любом случае возвращается значение, альтернативная ветка опускается
* Д16. Отсутствуют лишние приведения и проверки типов
* Д17. Там где возможно, в присвоении значения вместо if используется тернарный оператор
* Д18. Условия упрощены

### Магия

* Д19. В коде не используются «магические значения», под каждое из них заведена отдельная переменная, названная как константа

### Оптимальность

* Д20. Константы, используемые внутри функций создаются вне функций и используются повторно через замыкания
* Д21. Поиск элементов по селекторам делается минимальное количество раз, после этого ссылки на элементы сохраняются
* Д22. Массивы и объекты, содержимое которых вычисляется, собираются один раз, а после этого только переиспользуются
* Д23. Изменения применяются точечно

### Сложность. Читаемость.

* Д24. Для каждого события используется отдельный обработчик
* Д25. Длинные функции и методы разбиты на несколько небольших
* Д26. Для работы с JS-коллекциями используются итераторы для массивов
* Д27. Оператор присваивания не используется как часть выражения
